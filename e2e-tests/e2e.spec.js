import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { 
  createTempTestDir, 
  cleanupTempDir, 
  createTestPackageJson, 
  createTestBunoshfile 
} from './helpers/test-env.js';
import { 
  runBunoshCommand, 
  runSystemCommand, 
  checkBunoshAvailable 
} from './helpers/command-runner.js';

// Check if Bun is available for testing
const isBunAvailable = await checkBunoshAvailable();

describe('Bunosh End-to-End Tests', () => {
  let testDir;
  let originalCwd;

  beforeEach(() => {
    originalCwd = process.cwd();
    testDir = createTempTestDir();
    process.chdir(testDir);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    cleanupTempDir(testDir);
  });

  describe.skipIf(!isBunAvailable)('Environment Setup', () => {
    it('should have bunosh binary available', async () => {
      expect(isBunAvailable).toBe(true);
    });

    it('should create isolated test directory', () => {
      expect(fs.existsSync(testDir)).toBe(true);
      expect(process.cwd()).toBe(testDir);
    });
  });

  describe.skipIf(!isBunAvailable)('Bunosh Initialization', () => {
    it('should initialize Bunoshfile with bunosh init', async () => {
      const result = await runBunoshCommand('init', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      
      // Check that Bunoshfile.js was created
      const bunoshfilePath = path.join(testDir, 'Bunoshfile.js');
      expect(fs.existsSync(bunoshfilePath)).toBe(true);
      
      // Check Bunoshfile content
      const content = fs.readFileSync(bunoshfilePath, 'utf8');
      expect(content).toContain('export async function');
      expect(content).toContain('helloWorld');
    });

    it('should show error message without Bunoshfile', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      // Without a Bunoshfile, bunosh shows an error and exits with code 1
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stdout).toContain('bunosh init');
    });
  });

  describe.skipIf(!isBunAvailable)('Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should execute simple exec task', async () => {
      const result = await runBunoshCommand('simple:exec', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // The exec task may have different output format, just check it ran without error
      expect(result.exitCode).toBe(0);
    });

    it('should execute file task and create output file', async () => {
      const result = await runBunoshCommand('file:task custom-file.txt', { cwd: testDir });
      
      // File task should complete without errors
      expect(result.success).toBe(true);
      
      // Check that file was created
      const outputFile = path.join(testDir, 'custom-file.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('Generated by Bunosh test task');
    });

    it('should execute yell task with ASCII art output', async () => {
      const result = await runBunoshCommand('yell:task TESTING', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // ASCII art task should run successfully
      expect(result.exitCode).toBe(0);
    });

    it('should execute fetch task', async () => {
      const result = await runBunoshCommand('fetch:task', { 
        cwd: testDir,
        timeout: 20000 // Longer timeout for network request
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Fetched data:');
    });

    it('should handle task with arguments and options', async () => {
      const result = await runBunoshCommand('task:with-args World --greeting=Hi', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, World!');
    });

    it('should handle failing task properly', async () => {
      const result = await runBunoshCommand('failing:task', { 
        cwd: testDir,
        env: { NODE_ENV: 'test' }
      });
      
      // Task should complete but show failures in output
      expect(result.success).toBe(true); // Process succeeds in test mode
      expect(result.exitCode).toBe(0);   // Exit code 0 in test mode
      expect(result.stdout).toContain('Failed: 1'); // But reports failure
      
      // Check for failure indication (different formats in CI vs local)
      const hasExitCodeMessage = result.stdout.includes('exit code: 1') || result.stdout.includes('Exit code: 1');
      const hasCIErrorFormat = result.stdout.includes('❌ [exec]');
      expect(hasExitCodeMessage || hasCIErrorFormat).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('Parallel Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should execute parallel tasks with prefixes', async () => {
      const result = await runBunoshCommand('parallel:task', { 
        cwd: testDir,
        timeout: 20000
      });
      
      expect(result.success).toBe(true);
      
      // Check for task outputs
      expect(result.stdout).toContain('Task 1 output');
      expect(result.stdout).toContain('Task 2 output');
      expect(result.stdout).toContain('Task 3 output');
      
      // Check for angle bracket prefixes (when tasks run in parallel)
      const hasParallelPrefixes = result.stdout.includes('❰1❱') || 
                                result.stdout.includes('❰2❱') || 
                                result.stdout.includes('❰3❱');
      expect(hasParallelPrefixes).toBe(true);
    });

    it('should execute composite task calling other tasks', async () => {
      const result = await runBunoshCommand('composite:task', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
      expect(result.stdout).toContain('Composite task completed');
      
      // Check that file was created by composite task
      const outputFile = path.join(testDir, 'composite-output.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('NPM Scripts Integration', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir, {
        'custom-script': 'echo "Custom npm script executed"',
        'bunosh-script': 'bunosh simple:exec' // This should be filtered out
      });
    });

    it('should list npm scripts in help output', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('npm:test');
      expect(result.stdout).toContain('npm:build');
      expect(result.stdout).toContain('npm:custom-script');
      
      // Should not contain bunosh scripts
      expect(result.stdout).not.toContain('npm:bunosh-script');
    });

    it('should execute npm script through bunosh', async () => {
      const result = await runBunoshCommand('npm:custom-script', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Custom npm script executed');
    });

    it('should execute standard npm test script', async () => {
      const result = await runBunoshCommand('npm:test', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('running test');
    });
  });

  describe.skipIf(!isBunAvailable)('Command Listing and Help', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should show bunosh and npm commands in separate sections', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      const lines = result.stdout.split('\n');
      
      // Find Commands section
      const commandsStartIndex = lines.findIndex(line => line.includes('Commands:'));
      const commandsEndIndex = lines.findIndex((line, idx) => 
        idx > commandsStartIndex && line.includes('NPM Scripts:')
      );
      
      // Find NPM Scripts section  
      const npmStartIndex = lines.findIndex(line => line.includes('NPM Scripts:'));
      const npmEndIndex = lines.findIndex((line, idx) => 
        idx > npmStartIndex && line.includes('Special Commands:')
      );
      
      expect(commandsStartIndex).toBeGreaterThan(-1);
      expect(npmStartIndex).toBeGreaterThan(-1);
      expect(commandsEndIndex).toBeGreaterThan(commandsStartIndex);
      expect(npmEndIndex).toBeGreaterThan(npmStartIndex);
      
      // Parse bunosh commands section
      const bunoshCommandSection = lines.slice(commandsStartIndex + 1, commandsEndIndex);
      const bunoshCommands = bunoshCommandSection
        .filter(line => line.trim() && !line.includes('Commands:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.includes(':') && !cmd.startsWith('npm:'));
      
      // Parse npm commands section
      const npmCommandSection = lines.slice(npmStartIndex + 1, npmEndIndex);
      const npmCommands = npmCommandSection
        .filter(line => line.trim() && !line.includes('NPM Scripts:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.startsWith('npm:'));
      
      // Verify bunosh commands are alphabetically ordered
      const sortedBunoshCommands = [...bunoshCommands].sort();
      expect(bunoshCommands).toEqual(sortedBunoshCommands);
      
      // Verify npm commands are alphabetically ordered
      const sortedNpmCommands = [...npmCommands].sort();
      expect(npmCommands).toEqual(sortedNpmCommands);
      
      // Should contain both bunosh and npm commands
      expect(bunoshCommands.some(cmd => 
        ['simple:exec', 'fetch:task', 'file:task', 'yell:task', 'composite:task', 'parallel:task', 'task:with-args', 'failing:task'].includes(cmd)
      )).toBe(true);
      
      expect(npmCommands.some(cmd => cmd.startsWith('npm:'))).toBe(true);
    });

    it('should show command descriptions and usage', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Simple exec command');
      expect(result.stdout).toContain('Fetch data from API');
      expect(result.stdout).toContain('Task with arguments and options');
    });
  });

  describe.skipIf(!isBunAvailable)('Error Handling', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should handle unknown command gracefully', async () => {
      const result = await runBunoshCommand('unknown:command', { cwd: testDir });
      
      // Commander shows help and continues normally for unknown commands
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Unknown command unknown:command');
      expect(result.stdout).toContain('Usage: bunosh [-e <code>] <command> <args> [options]');
    });

    it('should handle missing Bunoshfile', async () => {
      // Remove Bunoshfile
      fs.unlinkSync(path.join(testDir, 'Bunoshfile.js'));
      
      const result = await runBunoshCommand('some:command', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
    });
  });

  describe.skipIf(!isBunAvailable)('Personal Commands Feature', () => {
    let tempHomeDir;
    let originalHome;
    
    beforeEach(() => {
      // Set up test environment with home directory
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
      
      // Create temporary home directory
      tempHomeDir = fs.mkdtempSync(path.join(process.env.TMPDIR || '/tmp', 'bunosh-e2e-home-'));
      originalHome = process.env.HOME;
      process.env.HOME = tempHomeDir;
    });
    
    afterEach(() => {
      // Restore original HOME
      process.env.HOME = originalHome;
      
      // Clean up temporary home directory
      if (fs.existsSync(tempHomeDir)) {
        fs.rmSync(tempHomeDir, { recursive: true, force: true });
      }
    });

    it('should work without personal commands', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).not.toContain('My Commands');
      expect(result.stdout).not.toContain('my:');
    });

    it('should load and display personal commands when home Bunoshfile exists', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
/**
 * Home deployment task
 */
export function deploy(env = 'staging') {
  console.log(\`Deploying to \${env} from home directory\`);
}

/**
 * Personal backup utility
 */
export function backup() {
  console.log('Creating personal backup...');
}
`);
      
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('My Commands (from ~/Bunoshfile.js):');
      expect(result.stdout).toContain('my:deploy');
      expect(result.stdout).toContain('my:backup');
      expect(result.stdout).toContain('Home deployment task');
      expect(result.stdout).toContain('Personal backup utility');
    });

    it('should execute personal commands with my: prefix', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'Home User') {
  console.log(\`Hello from home, \${name}!\`);
}
`);
      
      const result = await runBunoshCommand('my:greet', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from home, Home User!');
    });

    it('should execute personal commands with parameters', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'World', opts = { greeting: 'Hello' }) {
  console.log(\`\${opts.greeting}, \${name} from home!\`);
}
`);
      
      const result = await runBunoshCommand('my:greet Claude --greeting Hi', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, Claude from home!');
    });

    it('should handle personal commands alongside project commands', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function homeTask() {
  console.log('Executed from home');
}
`);
      
      // Test that both project and personal commands work
      const homeResult = await runBunoshCommand('my:homeTask', { cwd: testDir });
      const projectResult = await runBunoshCommand('simple:exec', { cwd: testDir });
      
      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Executed from home');
      
      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Hello from exec');
    });

    it('should handle home Bunoshfile with syntax errors gracefully', async () => {
      // Create invalid home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function badTask() {
  console.log('Missing quote);
}
`);
      
      // Should still be able to list commands (home tasks will be skipped)
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // Should show warning but continue working
      expect(result.stdout).not.toContain('my:badTask');
    });

    it('should allow same function names in personal and project commands without conflict', async () => {
      // Create personal Bunoshfile with same function name as project
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function build() {
  console.log('Building from home directory');
}
`);
      
      // Add build task to project Bunoshfile
      const projectBunoshfile = path.join(testDir, 'Bunoshfile.js');
      const existingContent = fs.readFileSync(projectBunoshfile, 'utf-8');
      fs.writeFileSync(projectBunoshfile, existingContent + `
export function build() {
  console.log('Building from project directory');
}
`);
      
      const helpResult = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(helpResult.success).toBe(true);
      expect(helpResult.stdout).toContain('build '); // Project build command
      expect(helpResult.stdout).toContain('my:build'); // Home build command
      
      // Test execution of both
      const projectResult = await runBunoshCommand('build', { cwd: testDir });
      const homeResult = await runBunoshCommand('my:build', { cwd: testDir });
      
      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Building from project directory');
      
      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Building from home directory');
    });

    it('should show personal commands in correct alphabetical order with other commands', async () => {
      // Create personal Bunoshfile with commands that should appear in alphabetical order
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function aHomeTask() {
  console.log('First alphabetically');
}

export function zHomeTask() {
  console.log('Last alphabetically');
}
`);
      
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      // Extract command lines from help output
      const lines = result.stdout.split('\n');
      const commandLines = lines.filter(line => 
        line.trim().match(/^[a-z-:]+/) && 
        !line.includes('NPM Scripts:') && 
        !line.includes('My Tasks:') &&
        !line.includes('Special Commands:')
      );
      
      // Should contain both personal commands with my: prefix
      const personalCommandsInHelp = commandLines.filter(line => line.includes('my:'));
      expect(personalCommandsInHelp.length).toBeGreaterThan(0);
    });
  });
});