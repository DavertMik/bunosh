import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { 
  createTempTestDir, 
  cleanupTempDir, 
  createTestPackageJson, 
  createTestBunoshfile 
} from './helpers/test-env.js';
import { 
  runBunoshCommand, 
  runSystemCommand, 
  checkBunoshAvailable 
} from './helpers/command-runner.js';

describe('Bunosh End-to-End Tests', () => {
  let testDir;
  let originalCwd;

  beforeEach(() => {
    originalCwd = process.cwd();
    testDir = createTempTestDir();
    process.chdir(testDir);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    cleanupTempDir(testDir);
  });

  describe('Environment Setup', () => {
    it('should have bunosh binary available', async () => {
      const available = await checkBunoshAvailable();
      // If this fails, it might be due to runtime environment differences
      expect(available).toBe(true);
    }, 10000);

    it('should create isolated test directory', () => {
      expect(fs.existsSync(testDir)).toBe(true);
      expect(process.cwd()).toBe(testDir);
    });
  });

  describe('Bunosh Initialization', () => {
    it('should initialize Bunoshfile with bunosh init', async () => {
      const result = await runBunoshCommand('init', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      
      // Check that Bunoshfile.js was created
      const bunoshfilePath = path.join(testDir, 'Bunoshfile.js');
      expect(fs.existsSync(bunoshfilePath)).toBe(true);
      
      // Check Bunoshfile content
      const content = fs.readFileSync(bunoshfilePath, 'utf8');
      expect(content).toContain('export async function');
      expect(content).toContain('helloWorld');
    });

    it('should show error message without Bunoshfile', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      // Without a Bunoshfile, bunosh shows an error and exits with code 1
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stdout).toContain('bunosh init');
    });
  });

  describe('Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should execute simple exec task', async () => {
      const result = await runBunoshCommand('simple:exec', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // The exec task may have different output format, just check it ran without error
      expect(result.exitCode).toBe(0);
    });

    it('should execute file task and create output file', async () => {
      const result = await runBunoshCommand('file:task custom-file.txt', { cwd: testDir });
      
      // File task should complete without errors
      expect(result.success).toBe(true);
      
      // Check that file was created
      const outputFile = path.join(testDir, 'custom-file.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('Generated by Bunosh test task');
    });

    it('should execute yell task with ASCII art output', async () => {
      const result = await runBunoshCommand('yell:task TESTING', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // ASCII art task should run successfully
      expect(result.exitCode).toBe(0);
    });

    it('should execute fetch task', async () => {
      const result = await runBunoshCommand('fetch:task', { 
        cwd: testDir,
        timeout: 20000 // Longer timeout for network request
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Fetched data:');
    });

    it('should handle task with arguments and options', async () => {
      const result = await runBunoshCommand('task:with-args World --greeting=Hi', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, World!');
    });

    it('should handle failing task properly', async () => {
      const result = await runBunoshCommand('failing:task', { cwd: testDir });
      
      // Task should complete but show failures in output
      expect(result.success).toBe(true); // Process succeeds in test mode
      expect(result.exitCode).toBe(0);   // Exit code 0 in test mode
      expect(result.stdout).toContain('Failed: 1'); // But reports failure
      
      // Check for failure indication (different formats in CI vs local)
      const hasExitCodeMessage = result.stdout.includes('exit code: 1') || result.stdout.includes('Exit code: 1');
      const hasCIErrorFormat = result.stdout.includes('❌ [exec]');
      expect(hasExitCodeMessage || hasCIErrorFormat).toBe(true);
    });
  });

  describe('Parallel Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should execute parallel tasks with prefixes', async () => {
      const result = await runBunoshCommand('parallel:task', { 
        cwd: testDir,
        timeout: 20000
      });
      
      expect(result.success).toBe(true);
      
      // Check for task outputs
      expect(result.stdout).toContain('Task 1 output');
      expect(result.stdout).toContain('Task 2 output');
      expect(result.stdout).toContain('Task 3 output');
      
      // Check for angle bracket prefixes (when tasks run in parallel)
      const hasParallelPrefixes = result.stdout.includes('❰1❱') || 
                                result.stdout.includes('❰2❱') || 
                                result.stdout.includes('❰3❱');
      expect(hasParallelPrefixes).toBe(true);
    });

    it('should execute composite task calling other tasks', async () => {
      const result = await runBunoshCommand('composite:task', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
      expect(result.stdout).toContain('Composite task completed');
      
      // Check that file was created by composite task
      const outputFile = path.join(testDir, 'composite-output.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });

  describe('NPM Scripts Integration', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir, {
        'custom-script': 'echo "Custom npm script executed"',
        'bunosh-script': 'bunosh simple:exec' // This should be filtered out
      });
    });

    it('should list npm scripts in help output', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('npm:test');
      expect(result.stdout).toContain('npm:build');
      expect(result.stdout).toContain('npm:custom-script');
      
      // Should not contain bunosh scripts
      expect(result.stdout).not.toContain('npm:bunosh-script');
    });

    it('should execute npm script through bunosh', async () => {
      const result = await runBunoshCommand('npm:custom-script', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Custom npm script executed');
    });

    it('should execute standard npm test script', async () => {
      const result = await runBunoshCommand('npm:test', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('running test');
    });
  });

  describe('Command Listing and Help', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should show mixed bunosh and npm commands in alphabetical order', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      const lines = result.stdout.split('\n');
      
      // Find command section more robustly
      const commandsStartIndex = lines.findIndex(line => line.includes('Commands:'));
      let commandsEndIndex = lines.findIndex((line, idx) => 
        idx > commandsStartIndex && (line.includes('Special Commands:') || line.includes('Options:'))
      );
      
      // If no end found, use end of output
      if (commandsEndIndex === -1) {
        commandsEndIndex = lines.length;
      }
      
      const commandSection = lines.slice(commandsStartIndex + 1, commandsEndIndex);
      
      // More robust command parsing
      const commands = commandSection
        .filter(line => line.trim()) // Remove empty lines
        .filter(line => !line.includes('Commands:') && !line.includes('Usage:')) // Remove headers
        .map(line => {
          const trimmed = line.trim();
          // Handle both "  command   description" and "command description" formats
          if (trimmed && !trimmed.startsWith('Usage:')) {
            return trimmed.split(/\s+/)[0];
          }
          return null;
        })
        .filter(cmd => cmd && cmd.length > 0 && !cmd.startsWith('Usage:'));
      
      // Verify alphabetical ordering
      const sortedCommands = [...commands].sort();
      expect(commands).toEqual(sortedCommands);
      
      // Should contain both bunosh and npm commands
      // More flexible check - look for any command that matches expected patterns
      const hasBunoshCommand = commands.some(cmd => 
        ['simple:exec', 'fetch:task', 'file:task', 'yell:task', 'composite:task', 'parallel:task', 'task:with-args', 'failing:task'].includes(cmd)
      );
      const hasNpmCommand = commands.some(cmd => cmd.startsWith('npm:'));
      
      // If we don't find expected commands, log for debugging but make test more flexible
      if (!hasBunoshCommand || !hasNpmCommand) {
        console.log('DEBUG: Commands found:', commands);
        console.log('DEBUG: Bunosh commands present:', commands.filter(cmd => cmd.includes(':')));
        console.log('DEBUG: NPM commands present:', commands.filter(cmd => cmd.startsWith('npm:')));
      }
      
      expect(hasBunoshCommand).toBe(true);
      expect(commands.some(cmd => cmd.startsWith('npm:'))).toBe(true);
    });

    it('should show command descriptions and usage', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Simple exec command');
      expect(result.stdout).toContain('Fetch data from API');
      expect(result.stdout).toContain('Task with arguments and options');
    });
  });

  describe('Error Handling', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should handle unknown command gracefully', async () => {
      const result = await runBunoshCommand('unknown:command', { cwd: testDir });
      
      // Commander shows help and continues normally for unknown commands
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Unknown command unknown:command');
      expect(result.stdout).toContain('Usage: bunosh <command>');
    });

    it('should handle missing Bunoshfile', async () => {
      // Remove Bunoshfile
      fs.unlinkSync(path.join(testDir, 'Bunoshfile.js'));
      
      const result = await runBunoshCommand('some:command', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
    });
  });
});