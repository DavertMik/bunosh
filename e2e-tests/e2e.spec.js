import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { 
  createTempTestDir, 
  cleanupTempDir, 
  createTestPackageJson, 
  createTestBunoshfile 
} from './helpers/test-env.js';
import { 
  runBunoshCommand, 
  runBunoshScript,
  runSystemCommand, 
  checkBunoshAvailable 
} from './helpers/command-runner.js';
import { cleanTestOutput } from './helpers/test-utils.js';

// Check if Bun is available for testing
const isBunAvailable = await checkBunoshAvailable();

describe('Bunosh End-to-End Tests', () => {
  let testDir;
  let originalCwd;

  beforeEach(() => {
    originalCwd = process.cwd();
    testDir = createTempTestDir();
    process.chdir(testDir);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    cleanupTempDir(testDir);
  });

  describe.skipIf(!isBunAvailable)('Environment Setup', () => {
    it('should have bunosh binary available', async () => {
      expect(isBunAvailable).toBe(true);
    });

    it('should create isolated test directory', () => {
      expect(fs.existsSync(testDir)).toBe(true);
      expect(process.cwd()).toBe(testDir);
    });
  });

  describe.skipIf(!isBunAvailable)('Bunosh Initialization', () => {
    it('should initialize Bunoshfile with bunosh init', async () => {
      const result = await runBunoshCommand('init', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      
      // Check that Bunoshfile.js was created
      const bunoshfilePath = path.join(testDir, 'Bunoshfile.js');
      expect(fs.existsSync(bunoshfilePath)).toBe(true);
      
      // Check Bunoshfile content
      const content = fs.readFileSync(bunoshfilePath, 'utf8');
      expect(content).toContain('export async function');
      expect(content).toContain('helloWorld');
    });

    it('should show error message without Bunoshfile', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      // Without a Bunoshfile, bunosh shows an error and exits with code 1
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stdout).toContain('bunosh init');
    });
  });

  describe.skipIf(!isBunAvailable)('Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should execute simple exec task', async () => {
      const result = await runBunoshCommand('simple-exec', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // The exec task may have different output format, just check it ran without error
      expect(result.exitCode).toBe(0);
    });

    it('should execute file task and create output file', async () => {
      const result = await runBunoshCommand('file-task custom-file.txt', { cwd: testDir });
      
      // File task should complete without errors
      expect(result.success).toBe(true);
      
      // Check that file was created
      const outputFile = path.join(testDir, 'custom-file.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('Generated by Bunosh test task');
    });

    it('should execute yell task with ASCII art output', async () => {
      const result = await runBunoshCommand('yell-task TESTING', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // ASCII art task should run successfully
      expect(result.exitCode).toBe(0);
    });

    it('should execute fetch task', async () => {
      const result = await runBunoshCommand('fetch-task', {
        cwd: testDir,
        timeout: 20000 // Longer timeout for network request
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Fetched data:');
    });

    it('should handle task with arguments and options', async () => {
      const result = await runBunoshCommand('task-with-args World Hi', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, World!');
    });

    it('should handle failing task properly', async () => {
      const result = await runBunoshCommand('failing-task', {
        cwd: testDir,
        env: { NODE_ENV: 'test' }
      });
      
      // Task should complete but show failures in output
      expect(result.success).toBe(true); // Process succeeds in test mode
      expect(result.exitCode).toBe(0);   // Exit code 0 in test mode
      expect(result.stdout).toContain('Failed: 1'); // But reports failure (only subtask fails, parent returns TaskResult)
      
      // Check for failure indication (different formats in CI vs local)
      const hasExitCodeMessage = result.stdout.includes('exit code: 1') || result.stdout.includes('Exit code: 1');
      const hasCIErrorFormat = result.stdout.includes('❌ [exec]');
      expect(hasExitCodeMessage || hasCIErrorFormat).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('Parallel Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should execute parallel tasks with prefixes', async () => {
      const result = await runBunoshCommand('parallel-task', {
        cwd: testDir,
        timeout: 20000
      });
      
      expect(result.success).toBe(true);
      
      // Check for task outputs
      expect(result.stdout).toContain('Task 1 output');
      expect(result.stdout).toContain('Task 2 output');
      expect(result.stdout).toContain('Task 3 output');
      
      // Check for angle bracket prefixes (when tasks run in parallel)
      const hasParallelPrefixes = result.stdout.includes('❰1❱') || 
                                result.stdout.includes('❰2❱') || 
                                result.stdout.includes('❰3❱');
      expect(hasParallelPrefixes).toBe(true);
    });

    it('should execute composite task calling other tasks', async () => {
      const result = await runBunoshCommand('composite-task', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
      expect(result.stdout).toContain('Composite task completed');
      
      // Check that file was created by composite task
      const outputFile = path.join(testDir, 'composite-output.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('NPM Scripts Integration', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir, {
        'custom-script': 'echo "Custom npm script executed"',
        'bunosh-script': 'bunosh simple:exec' // This should be filtered out
      });
    });

    it('should list npm scripts in help output', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('npm:test');
      expect(result.stdout).toContain('npm:build');
      expect(result.stdout).toContain('npm:custom-script');
      
      // Should not contain bunosh scripts
      expect(result.stdout).not.toContain('npm:bunosh-script');
    });

    it('should execute npm script through bunosh', async () => {
      const result = await runBunoshCommand('npm:custom-script', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Custom npm script executed');
    });

    it('should execute standard npm test script', async () => {
      const result = await runBunoshCommand('npm:test', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('running test');
    });
  });

  describe.skipIf(!isBunAvailable)('Command Listing and Help', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should show bunosh and npm commands in separate sections', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      const lines = result.stdout.split('\n');
      
      // Find Commands section
      const commandsStartIndex = lines.findIndex(line => line.includes('Commands:'));
      const commandsEndIndex = lines.findIndex((line, idx) => 
        idx > commandsStartIndex && line.includes('NPM Scripts:')
      );
      
      // Find NPM Scripts section  
      const npmStartIndex = lines.findIndex(line => line.includes('NPM Scripts:'));
      const npmEndIndex = lines.findIndex((line, idx) => 
        idx > npmStartIndex && line.includes('Special Commands:')
      );
      
      expect(commandsStartIndex).toBeGreaterThan(-1);
      expect(npmStartIndex).toBeGreaterThan(-1);
      expect(commandsEndIndex).toBeGreaterThan(commandsStartIndex);
      expect(npmEndIndex).toBeGreaterThan(npmStartIndex);
      
      // Parse bunosh commands section
      const bunoshCommandSection = lines.slice(commandsStartIndex + 1, commandsEndIndex);
      const bunoshCommands = bunoshCommandSection
        .filter(line => line.trim() && !line.includes('Commands:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.includes('-') && !cmd.startsWith('npm:'));
      
      // Parse npm commands section
      const npmCommandSection = lines.slice(npmStartIndex + 1, npmEndIndex);
      const npmCommands = npmCommandSection
        .filter(line => line.trim() && !line.includes('NPM Scripts:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.startsWith('npm:'));
      
      // Verify bunosh commands are alphabetically ordered
      const sortedBunoshCommands = [...bunoshCommands].sort();
      expect(bunoshCommands).toEqual(sortedBunoshCommands);
      
      // Verify npm commands are alphabetically ordered
      const sortedNpmCommands = [...npmCommands].sort();
      expect(npmCommands).toEqual(sortedNpmCommands);
      
      // Should contain both bunosh and npm commands
      expect(bunoshCommands.some(cmd =>
        ['simple-exec', 'fetch-task', 'file-task', 'yell-task', 'composite-task', 'parallel-task', 'task-with-args', 'failing-task'].includes(cmd)
      )).toBe(true);
      
      expect(npmCommands.some(cmd => cmd.startsWith('npm:'))).toBe(true);
    });

    it('should show command descriptions and usage', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Simple exec command');
      expect(result.stdout).toContain('Fetch data from API');
      expect(result.stdout).toContain('Task with arguments and options');
    });
  });

  describe.skipIf(!isBunAvailable)('Error Handling', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should handle unknown command gracefully', async () => {
      const result = await runBunoshCommand('unknown:command', { cwd: testDir });

      // Unknown commands should show help and exit with error code
      expect(result.success).toBe(false);
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Unknown command unknown:command');
      expect(result.stdout).toContain('Usage: bunosh [-e <code>] <command> <args> [options]');
    });

    it('should handle missing Bunoshfile', async () => {
      // Remove Bunoshfile
      fs.unlinkSync(path.join(testDir, 'Bunoshfile.js'));
      
      const result = await runBunoshCommand('some:command', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
    });
  });

describe.skipIf(!isBunAvailable)('Personal Commands Feature', () => {
    let tempHomeDir;
    let originalHome;

    beforeEach(() => {
      // Set up test environment with home directory
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);

      // Create temporary home directory
      tempHomeDir = fs.mkdtempSync(path.join(process.env.TMPDIR || '/tmp', 'bunosh-e2e-home-'));
      originalHome = process.env.HOME;
      process.env.HOME = tempHomeDir;
    });

    afterEach(() => {
      // Restore original HOME
      process.env.HOME = originalHome;

      // Clean up temporary home directory
      if (fs.existsSync(tempHomeDir)) {
        fs.rmSync(tempHomeDir, { recursive: true, force: true });
      }
    });

    it('should work without personal commands', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).not.toContain('My Commands');
      expect(result.stdout).not.toContain('my:');
    });

    it('should load and display personal commands when home Bunoshfile exists', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
/**
 * Home deployment task
 */
export function deploy(env = 'staging') {
  console.log(\`Deploying to \${env} from home directory\`);
}

/**
 * Personal backup utility
 */
export function backup() {
  console.log('Creating personal backup...');
}
`);

      const result = await runBunoshCommand('--help', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('My Commands (from ~/Bunoshfile.js):');
      expect(result.stdout).toContain('my:deploy');
      expect(result.stdout).toContain('my:backup');
      expect(result.stdout).toContain('Home deployment task');
      expect(result.stdout).toContain('Personal backup utility');
    });

    it('should execute personal commands with my: prefix', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'Home User') {
  console.log(\`Hello from home, \${name}!\`);
}
`);

      const result = await runBunoshCommand('my:greet', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from home, Home User!');
    });

    it('should execute personal commands with parameters', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'World', opts = { greeting: 'Hello' }) {
  console.log(\`\${opts.greeting}, \${name} from home!\`);
}
`);

      const result = await runBunoshCommand('my:greet Claude --greeting Hi', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, Claude from home!');
    });

    it('should handle personal commands alongside project commands', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function homeTask() {
  console.log('Executed from home');
}
`);

      // Test that both project and personal commands work
      const homeResult = await runBunoshCommand('my:homeTask', { cwd: testDir });
      const projectResult = await runBunoshCommand('simple-exec', { cwd: testDir });

      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Executed from home');

      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Hello from exec');
    });

    it('should handle home Bunoshfile with syntax errors gracefully', async () => {
      // Create invalid home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function badTask() {
  console.log('Missing quote);
}
`);

      // Should still be able to list commands (home tasks will be skipped)
      const result = await runBunoshCommand('--help', { cwd: testDir });

      expect(result.success).toBe(true);
      // Should show warning but continue working
      expect(result.stdout).not.toContain('my:badTask');
    });

    it('should allow same function names in personal and project commands without conflict', async () => {
      // Create personal Bunoshfile with same function name as project
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function build() {
  console.log('Building from home directory');
}
`);

      // Add build task to project Bunoshfile
      const projectBunoshfile = path.join(testDir, 'Bunoshfile.js');
      const existingContent = fs.readFileSync(projectBunoshfile, 'utf8');
      fs.writeFileSync(projectBunoshfile, existingContent + `
export function build() {
  console.log('Building from project directory');
}
`);

      const helpResult = await runBunoshCommand('--help', { cwd: testDir });

      expect(helpResult.success).toBe(true);
      expect(helpResult.stdout).toContain('build '); // Project build command
      expect(helpResult.stdout).toContain('my:build'); // Home build command

      // Test execution of both
      const projectResult = await runBunoshCommand('build', { cwd: testDir });
      const homeResult = await runBunoshCommand('my:build', { cwd: testDir });

      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Building from project directory');

      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Building from home directory');
    });

    it('should show personal commands in correct alphabetical order with other commands', async () => {
      // Create personal Bunoshfile with commands that should appear in alphabetical order
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function aHomeTask() {
  console.log('First alphabetically');
}

export function zHomeTask() {
  console.log('Last alphabetically');
}
`);

      const result = await runBunoshCommand('--help', { cwd: testDir });

      expect(result.success).toBe(true);

      // Extract command lines from help output
      const lines = result.stdout.split('\n');
      const commandLines = lines.filter(line => {
        // Remove ANSI color codes and trim whitespace
        const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, '').trim();
        return cleanLine.match(/^[a-z-:]+/) &&
               !line.includes('NPM Scripts:') &&
               !line.includes('My Commands:') &&
               !line.includes('Special Commands:');
      });

      // Should contain both personal commands with my: prefix
      const personalCommandsInHelp = commandLines.filter(line => line.includes('my:'));
      expect(personalCommandsInHelp.length).toBeGreaterThan(0);
    });
  });

  describe.skipIf(!isBunAvailable)('Custom Bunoshfile Loading', () => {
    beforeEach(() => {
      // Create default Bunoshfile
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should load commands from custom Bunoshfile with --bunoshfile option', async () => {
      // Create custom Bunoshfile
      const customBunoshfile = path.join(testDir, 'Bunoshfile.custom.js');
      fs.writeFileSync(customBunoshfile, `
/**
 * Custom task from alternative Bunoshfile
 */
export function customTask() {
  console.log('Custom task executed from alternative Bunoshfile');
}

/**
 * Another custom command
 */
export function alternativeCommand(message = 'Hello') {
  console.log(\`Alternative: \${message}\`);
}
`);

      // Test help output shows custom commands
      const helpResult = await runBunoshCommand('--bunoshfile Bunoshfile.custom.js --help', { cwd: testDir });

      expect(helpResult.success).toBe(true);
      expect(helpResult.stdout).toContain('custom:task');
      expect(helpResult.stdout).toContain('alternative:command');
      expect(helpResult.stdout).toContain('Custom task from alternative Bunoshfile');

      // Should not contain default commands
      expect(helpResult.stdout).not.toContain('simple-exec');
      expect(helpResult.stdout).not.toContain('fetch-task');
    });

    it('should execute commands from custom Bunoshfile', async () => {
      // Create custom Bunoshfile
      const customBunoshfile = path.join(testDir, 'Bunoshfile.dev.js');
      fs.writeFileSync(customBunoshfile, `
export function devTask(env = 'development') {
  console.log(\`Running in \${env} mode\`);
}
`);

      const result = await runBunoshCommand('--bunoshfile Bunoshfile.dev.js dev:task production', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Running in production mode');
    });

    it('should load Bunoshfile from different directory', async () => {
      // Create subdirectory with custom Bunoshfile
      const subDir = path.join(testDir, 'configs');
      fs.mkdirSync(subDir);

      const configBunoshfile = path.join(subDir, 'build-tasks.js');
      fs.writeFileSync(configBunoshfile, `
export function buildProd() {
  console.log('Building for production from config directory');
}
`);

      const result = await runBunoshCommand('--bunoshfile configs/build-tasks.js build:prod', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Building for production from config directory');
    });

    it('should work with BUNOSHFILE environment variable', async () => {
      // Create custom Bunoshfile
      const envBunoshfile = path.join(testDir, 'Bunoshfile.env.js');
      fs.writeFileSync(envBunoshfile, `
export function envTask() {
  console.log('Task executed via BUNOSHFILE environment variable');
}
`);

      const result = await runBunoshCommand('env:task', {
        cwd: testDir,
        env: { BUNOSHFILE: 'Bunoshfile.env.js' }
      });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Task executed via BUNOSHFILE environment variable');
    });

    it('should prioritize --bunoshfile option over BUNOSHFILE env var', async () => {
      // Create two custom Bunoshfiles
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.cli.js'), `
export function cliTask() {
  console.log('CLI option takes precedence');
}
`);

      fs.writeFileSync(path.join(testDir, 'Bunoshfile.env.js'), `
export function envTask() {
  console.log('Environment variable task');
}
`);

      const result = await runBunoshCommand('--bunoshfile Bunoshfile.cli.js cli:task', {
        cwd: testDir,
        env: { BUNOSHFILE: 'Bunoshfile.env.js' }
      });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('CLI option takes precedence');
      expect(result.stdout).not.toContain('Environment variable task');
    });

    it('should show appropriate error for non-existent custom Bunoshfile', async () => {
      const result = await runBunoshCommand('--bunoshfile non-existent.js --help', { cwd: testDir });

      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stderr).toContain('non-existent.js');
    });

    it('should change working directory to custom Bunoshfile directory', async () => {
      // Create subdirectory structure
      const subDir = path.join(testDir, 'project');
      fs.mkdirSync(subDir);

      // Create a file in subdirectory that the task will read
      fs.writeFileSync(path.join(subDir, 'config.txt'), 'project configuration');

      const customBunoshfile = path.join(subDir, 'Bunoshfile.js');
      fs.writeFileSync(customBunoshfile, `
const fs = require('fs');

export function readConfig() {
  // This should work because working directory changes to where Bunoshfile is located
  const config = fs.readFileSync('config.txt', 'utf8');
  console.log(\`Config: \${config}\`);
}
`);

      const result = await runBunoshCommand('--bunoshfile project/Bunoshfile.js read:config', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Config: project configuration');
    });

    it('should handle relative paths in BUNOSHFILE environment variable', async () => {
      // Create custom Bunoshfile in subdirectory
      const subDir = path.join(testDir, 'tasks');
      fs.mkdirSync(subDir);

      const relativeBunoshfile = path.join(subDir, 'custom.js');
      fs.writeFileSync(relativeBunoshfile, `
export function relativeTask() {
  console.log('Task from relative path via environment variable');
}
`);

      const result = await runBunoshCommand('relative:task', {
        cwd: testDir,
        env: { BUNOSHFILE: 'tasks/custom.js' }
      });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Task from relative path via environment variable');
    });

    it('should fall back to default Bunoshfile when BUNOSHFILE env var is empty', async () => {
      const result = await runBunoshCommand('simple-exec', {
        cwd: testDir,
        env: { BUNOSHFILE: '' }
      });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
    });
  });
  describe.skipIf(!isBunAvailable)('Personal Commands Feature', () => {
    let tempHomeDir;
    let originalHome;
    
    beforeEach(() => {
      // Set up test environment with home directory
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
      
      // Create temporary home directory
      tempHomeDir = fs.mkdtempSync(path.join(process.env.TMPDIR || '/tmp', 'bunosh-e2e-home-'));
      originalHome = process.env.HOME;
      process.env.HOME = tempHomeDir;
    });
    
    afterEach(() => {
      // Restore original HOME
      process.env.HOME = originalHome;
      
      // Clean up temporary home directory
      if (fs.existsSync(tempHomeDir)) {
        fs.rmSync(tempHomeDir, { recursive: true, force: true });
      }
    });

    it('should work without personal commands', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).not.toContain('My Commands');
      expect(result.stdout).not.toContain('my:');
    });

    it('should load and display personal commands when home Bunoshfile exists', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
/**
 * Home deployment task
 */
export function deploy(env = 'staging') {
  console.log(\`Deploying to \${env} from home directory\`);
}

/**
 * Personal backup utility
 */
export function backup() {
  console.log('Creating personal backup...');
}
`);
      
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('My Commands (from ~/Bunoshfile.js):');
      expect(result.stdout).toContain('my:deploy');
      expect(result.stdout).toContain('my:backup');
      expect(result.stdout).toContain('Home deployment task');
      expect(result.stdout).toContain('Personal backup utility');
    });

    it('should execute personal commands with my: prefix', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'Home User') {
  console.log(\`Hello from home, \${name}!\`);
}
`);
      
      const result = await runBunoshCommand('my:greet', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from home, Home User!');
    });

    it('should execute personal commands with parameters', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function greet(name = 'World', opts = { greeting: 'Hello' }) {
  console.log(\`\${opts.greeting}, \${name} from home!\`);
}
`);
      
      const result = await runBunoshCommand('my:greet Claude --greeting Hi', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, Claude from home!');
    });

    it('should handle personal commands alongside project commands', async () => {
      // Create home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function homeTask() {
  console.log('Executed from home');
}
`);
      
      // Test that both project and personal commands work
      const homeResult = await runBunoshCommand('my:homeTask', { cwd: testDir });
      const projectResult = await runBunoshCommand('simple:exec', { cwd: testDir });
      
      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Executed from home');
      
      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Hello from exec');
    });

    it('should handle home Bunoshfile with syntax errors gracefully', async () => {
      // Create invalid home Bunoshfile
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function badTask() {
  console.log('Missing quote);
}
`);
      
      // Should still be able to list commands (home tasks will be skipped)
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // Should show warning but continue working
      expect(result.stdout).not.toContain('my:badTask');
    });

    it('should allow same function names in personal and project commands without conflict', async () => {
      // Create personal Bunoshfile with same function name as project
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function build() {
  console.log('Building from home directory');
}
`);
      
      // Add build task to project Bunoshfile
      const projectBunoshfile = path.join(testDir, 'Bunoshfile.js');
      const existingContent = fs.readFileSync(projectBunoshfile, 'utf-8');
      fs.writeFileSync(projectBunoshfile, existingContent + `
export function build() {
  console.log('Building from project directory');
}
`);
      
      const helpResult = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(helpResult.success).toBe(true);
      expect(helpResult.stdout).toContain('build '); // Project build command
      expect(helpResult.stdout).toContain('my:build'); // Home build command
      
      // Test execution of both
      const projectResult = await runBunoshCommand('build', { cwd: testDir });
      const homeResult = await runBunoshCommand('my:build', { cwd: testDir });
      
      expect(projectResult.success).toBe(true);
      expect(projectResult.stdout).toContain('Building from project directory');
      
      expect(homeResult.success).toBe(true);
      expect(homeResult.stdout).toContain('Building from home directory');
    });

    it('should show personal commands in correct alphabetical order with other commands', async () => {
      // Create personal Bunoshfile with commands that should appear in alphabetical order
      const homeBunoshfile = path.join(tempHomeDir, 'Bunoshfile.js');
      fs.writeFileSync(homeBunoshfile, `
export function aHomeTask() {
  console.log('First alphabetically');
}

export function zHomeTask() {
  console.log('Last alphabetically');
}
`);
      
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      // Extract command lines from help output
      const lines = result.stdout.split('\n');
      const commandLines = lines.filter(line => {
        // Remove ANSI color codes and trim whitespace
        const cleanLine = line.replace(/\x1b\[[0-9;]*m/g, '').trim();
        return cleanLine.match(/^[a-z-:]+/) && 
               !line.includes('NPM Scripts:') && 
               !line.includes('My Commands:') &&
               !line.includes('Special Commands:');
      });
      
      // Should contain both personal commands with my: prefix
      const personalCommandsInHelp = commandLines.filter(line => line.includes('my:'));
      expect(personalCommandsInHelp.length).toBeGreaterThan(0);
    });
  });

  describe.skipIf(!isBunAvailable)('Custom Bunoshfile Loading', () => {
    beforeEach(() => {
      // Create default Bunoshfile
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should load commands from custom Bunoshfile with --bunoshfile option', async () => {
      // Create custom Bunoshfile
      const customBunoshfile = path.join(testDir, 'Bunoshfile.custom.js');
      fs.writeFileSync(customBunoshfile, `
/**
 * Custom task from alternative Bunoshfile
 */
export function customTask() {
  console.log('Custom task executed from alternative Bunoshfile');
}

/**
 * Another custom command
 */
export function alternativeCommand(message = 'Hello') {
  console.log(\`Alternative: \${message}\`);
}
`);

      // Test help output shows custom commands
      const helpResult = await runBunoshCommand('--bunoshfile Bunoshfile.custom.js --help', { cwd: testDir });
      
      expect(helpResult.success).toBe(true);
      expect(helpResult.stdout).toContain('custom:task');
      expect(helpResult.stdout).toContain('alternative:command');
      expect(helpResult.stdout).toContain('Custom task from alternative Bunoshfile');
      
      // Should not contain default commands
      expect(helpResult.stdout).not.toContain('simple:exec');
      expect(helpResult.stdout).not.toContain('fetch:task');
    });

    it('should execute commands from custom Bunoshfile', async () => {
      // Create custom Bunoshfile
      const customBunoshfile = path.join(testDir, 'Bunoshfile.dev.js');
      fs.writeFileSync(customBunoshfile, `
export function devTask(env = 'development') {
  console.log(\`Running in \${env} mode\`);
}
`);

      const result = await runBunoshCommand('--bunoshfile Bunoshfile.dev.js dev:task production', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Running in production mode');
    });

    it('should load Bunoshfile from different directory', async () => {
      // Create subdirectory with custom Bunoshfile
      const subDir = path.join(testDir, 'configs');
      fs.mkdirSync(subDir);
      
      const configBunoshfile = path.join(subDir, 'build-tasks.js');
      fs.writeFileSync(configBunoshfile, `
export function buildProd() {
  console.log('Building for production from config directory');
}
`);

      const result = await runBunoshCommand('--bunoshfile configs/build-tasks.js build:prod', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Building for production from config directory');
    });

    it('should work with BUNOSHFILE environment variable', async () => {
      // Create custom Bunoshfile
      const envBunoshfile = path.join(testDir, 'Bunoshfile.env.js');
      fs.writeFileSync(envBunoshfile, `
export function envTask() {
  console.log('Task executed via BUNOSHFILE environment variable');
}
`);

      const result = await runBunoshCommand('env:task', { 
        cwd: testDir,
        env: { BUNOSHFILE: 'Bunoshfile.env.js' }
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Task executed via BUNOSHFILE environment variable');
    });

    it('should prioritize --bunoshfile option over BUNOSHFILE env var', async () => {
      // Create two custom Bunoshfiles
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.cli.js'), `
export function cliTask() {
  console.log('CLI option takes precedence');
}
`);
      
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.env.js'), `
export function envTask() {
  console.log('Environment variable task');
}
`);

      const result = await runBunoshCommand('--bunoshfile Bunoshfile.cli.js cli:task', { 
        cwd: testDir,
        env: { BUNOSHFILE: 'Bunoshfile.env.js' }
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('CLI option takes precedence');
      expect(result.stdout).not.toContain('Environment variable task');
    });

    it('should show appropriate error for non-existent custom Bunoshfile', async () => {
      const result = await runBunoshCommand('--bunoshfile non-existent.js --help', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stderr).toContain('non-existent.js');
    });

    it('should change working directory to custom Bunoshfile directory', async () => {
      // Create subdirectory structure
      const subDir = path.join(testDir, 'project');
      fs.mkdirSync(subDir);
      
      // Create a file in subdirectory that the task will read
      fs.writeFileSync(path.join(subDir, 'config.txt'), 'project configuration');
      
      const customBunoshfile = path.join(subDir, 'Bunoshfile.js');
      fs.writeFileSync(customBunoshfile, `
const fs = require('fs');

export function readConfig() {
  // This should work because working directory changes to where Bunoshfile is located
  const config = fs.readFileSync('config.txt', 'utf8');
  console.log(\`Config: \${config}\`);
}
`);

      const result = await runBunoshCommand('--bunoshfile project/Bunoshfile.js read:config', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Config: project configuration');
    });

    it('should handle relative paths in BUNOSHFILE environment variable', async () => {
      // Create custom Bunoshfile in subdirectory
      const subDir = path.join(testDir, 'tasks');
      fs.mkdirSync(subDir);
      
      const relativeBunoshfile = path.join(subDir, 'custom.js');
      fs.writeFileSync(relativeBunoshfile, `
export function relativeTask() {
  console.log('Task from relative path via environment variable');
}
`);

      const result = await runBunoshCommand('relative:task', { 
        cwd: testDir,
        env: { BUNOSHFILE: 'tasks/custom.js' }
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Task from relative path via environment variable');
    });

    it('should fall back to default Bunoshfile when BUNOSHFILE env var is empty', async () => {
      const result = await runBunoshCommand('simple:exec', { 
        cwd: testDir,
        env: { BUNOSHFILE: '' }
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
    });
  });

  describe.skipIf(!isBunAvailable)('Task Formatting and Output', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should show parent task description in child exec commands', async () => {
      const script = `
        await task('Fetch all users', async () => {
          await exec\`echo "Fetching data..."\`;
          return 'Users fetched';
        });
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('✔ exec Fetch all users > echo "Fetching data..."');
    });

    it('should show numbered prefixes for parallel tasks', async () => {
      const script = `
        await Promise.all([
          task('Task 1', () => exec\`echo "Output 1"\`),
          task('Task 2', () => exec\`echo "Output 2"\`),
          task('Task 3', () => exec\`echo "Output 3"\`)
        ]);
      `;

      const result = await runBunoshScript(script, {
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });

      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      // First task may not have prefix due to race condition, but subsequent tasks should
      expect(cleaned.stdout).toMatch(/▶ task ❰2❱ Task 2/);
      expect(cleaned.stdout).toMatch(/▶ task ❰3❱ Task 3/);
      // Should have at least 2 tasks with prefixes (indicating parallel execution)
      const prefixMatches = cleaned.stdout.match(/▶ task ❰\d+❱/g) || [];
      expect(prefixMatches.length).toBeGreaterThan(1);
    });

    it('should not show prefixes for single tasks', async () => {
      const script = `
        await task('Single task', () => exec\`echo "Single task output"\`);
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('▶ task');
      expect(cleaned.stdout).toContain('Single task');
      expect(cleaned.stdout).not.toMatch(/✔ task ❰\\d+❱ Single task/);
    });

    it('should handle task failures correctly', async () => {
      const script = `
        try {
          await task('Task that fails', async () => {
            await exec\`sh -c "exit 1"\`;
          });
        } catch (e) {
          // Task failure should be caught
        }
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('✗ exec Task that fails > sh -c "exit 1"');
      expect(cleaned.stdout).toContain('✔ task Task that fails');
    });
  });

  describe.skipIf(!isBunAvailable)('Namespace Support', () => {
    it('should load multiple Bunoshfiles with namespaces', async () => {
      // Create main Bunoshfile
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function build() {
  console.log('Building main project...');
}

export function test() {
  console.log('Running main tests...');
}
`);

      // Create namespaced Bunoshfiles
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function start() {
  console.log('Starting dev server...');
}

export function debug() {
  console.log('Debugging application...');
}
`);

      fs.writeFileSync(path.join(testDir, 'Bunoshfile.api.js'), `
export function deploy() {
  console.log('Deploying API...');
}

export function test() {
  console.log('Running API tests...');
}
`);

      const result = await runBunoshCommand('', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      // Should show all commands from all namespaces
      expect(cleaned.stdout).toContain('build');
      expect(cleaned.stdout).toContain('test');
      expect(cleaned.stdout).toContain('dev:start');
      expect(cleaned.stdout).toContain('dev:debug');
      expect(cleaned.stdout).toContain('api:deploy');
      expect(cleaned.stdout).toContain('api:test');
    });

    it('should execute namespaced tasks correctly', async () => {
      // Create test files
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function shared() {
  console.log('Main shared task');
}
`);

      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function shared() {
  console.log('Dev shared task');
}

export function devOnly() {
  console.log('Dev only task');
}
`);

      // Test main task (no namespace)
      const result1 = await runBunoshCommand('shared', { cwd: testDir });
      const cleaned1 = cleanTestOutput(result1);
      expect(cleaned1.success).toBe(true);
      expect(cleaned1.stdout).toContain('Main shared task');

      // Test namespaced task
      const result2 = await runBunoshCommand('dev:shared', { cwd: testDir });
      const cleaned2 = cleanTestOutput(result2);
      expect(cleaned2.success).toBe(true);
      expect(cleaned2.stdout).toContain('Dev shared task');

      // Test namespace-only task
      const result3 = await runBunoshCommand('dev:dev-only', { cwd: testDir });
      const cleaned3 = cleanTestOutput(result3);
      expect(cleaned3.success).toBe(true);
      expect(cleaned3.stdout).toContain('Dev only task');
    });

    it('should handle task arguments and options in namespaced tasks', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function greet(name = 'World', enthusiastic = false) {
  const message = enthusiastic 
    ? "Hello " + name + "! Welcome to the amazing dev environment!"
    : "Hello " + name;
  console.log(message);
}
`);

      // Test with default values
      const result1 = await runBunoshCommand('dev:greet', { cwd: testDir });
      const cleaned1 = cleanTestOutput(result1);
      expect(cleaned1.success).toBe(true);
      expect(cleaned1.stdout).toContain('Hello World');

      // Test with arguments
      const result2 = await runBunoshCommand('dev:greet Alice', { cwd: testDir });
      const cleaned2 = cleanTestOutput(result2);
      expect(cleaned2.success).toBe(true);
      expect(cleaned2.stdout).toContain('Hello Alice');

      // Test with boolean argument
      const result3 = await runBunoshCommand('dev:greet Alice true', { cwd: testDir });
      const cleaned3 = cleanTestOutput(result3);
      expect(cleaned3.success).toBe(true);
      expect(cleaned3.stdout).toContain('Hello Alice! Welcome to the amazing dev environment!');
    });

    it('should show help for namespaced tasks', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
/**
 * Starts the development server
 * @param {number} port - The port to run on
 * @param {boolean} https - Enable HTTPS
 */
export function start(port = 3000, https = false) {
  console.log("Starting server on port " + port + " with HTTPS: " + https);
}
`);

      // Check that namespaced task appears in general help
      const result = await runBunoshCommand('--help', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('dev:start');
      expect(cleaned.stdout).toContain('Starts the development server');
      expect(cleaned.stdout).toContain('bunosh dev:start [port=3000] [https=false]');
    });

    it('should handle non-existent namespaced tasks gracefully', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function existing() {
  console.log('This exists');
}
`);

      const result = await runBunoshCommand('dev:nonexistent', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(false);
      expect(cleaned.stderr).toContain('Unknown command');
    });

    it('should work with no namespace Bunoshfile only', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function mainTask() {
  console.log('Main task executed');
}
`);

      const result = await runBunoshCommand('main-task', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('Main task executed');
    });

    it('should work with namespaced Bunoshfiles only', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function devTask() {
  console.log('Dev task executed');
}
`);

      const result = await runBunoshCommand('dev:dev-task', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('Dev task executed');
    });
  });
});