import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { 
  createTempTestDir, 
  cleanupTempDir, 
  createTestPackageJson, 
  createTestBunoshfile 
} from './helpers/test-env.js';
import { 
  runBunoshCommand, 
  runBunoshScript,
  runSystemCommand, 
  checkBunoshAvailable 
} from './helpers/command-runner.js';
import { cleanTestOutput } from './helpers/test-utils.js';

// Check if Bun is available for testing
const isBunAvailable = await checkBunoshAvailable();

describe('Bunosh End-to-End Tests', () => {
  let testDir;
  let originalCwd;

  beforeEach(() => {
    originalCwd = process.cwd();
    testDir = createTempTestDir();
    process.chdir(testDir);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    cleanupTempDir(testDir);
  });

  describe.skipIf(!isBunAvailable)('Environment Setup', () => {
    it('should have bunosh binary available', async () => {
      expect(isBunAvailable).toBe(true);
    });

    it('should create isolated test directory', () => {
      expect(fs.existsSync(testDir)).toBe(true);
      expect(process.cwd()).toBe(testDir);
    });
  });

  describe.skipIf(!isBunAvailable)('Bunosh Initialization', () => {
    it('should initialize Bunoshfile with bunosh init', async () => {
      const result = await runBunoshCommand('init', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      
      // Check that Bunoshfile.js was created
      const bunoshfilePath = path.join(testDir, 'Bunoshfile.js');
      expect(fs.existsSync(bunoshfilePath)).toBe(true);
      
      // Check Bunoshfile content
      const content = fs.readFileSync(bunoshfilePath, 'utf8');
      expect(content).toContain('export async function');
      expect(content).toContain('helloWorld');
    });

    it('should show error message without Bunoshfile', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      // Without a Bunoshfile, bunosh shows an error and exits with code 1
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stdout).toContain('bunosh init');
    });
  });

  describe.skipIf(!isBunAvailable)('Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should execute simple exec task', async () => {
      const result = await runBunoshCommand('simple-exec', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // The exec task may have different output format, just check it ran without error
      expect(result.exitCode).toBe(0);
    });

    it('should execute file task and create output file', async () => {
      const result = await runBunoshCommand('file-task custom-file.txt', { cwd: testDir });
      
      // File task should complete without errors
      expect(result.success).toBe(true);
      
      // Check that file was created
      const outputFile = path.join(testDir, 'custom-file.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('Generated by Bunosh test task');
    });

    it('should execute yell task with ASCII art output', async () => {
      const result = await runBunoshCommand('yell-task TESTING', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // ASCII art task should run successfully
      expect(result.exitCode).toBe(0);
    });

    it('should execute fetch task', async () => {
      const result = await runBunoshCommand('fetch-task', {
        cwd: testDir,
        timeout: 20000 // Longer timeout for network request
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Fetched data:');
    });

    it('should handle task with arguments and options', async () => {
      const result = await runBunoshCommand('task-with-args World Hi', { cwd: testDir });

      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, World!');
    });

    it('should handle failing task properly', async () => {
      const result = await runBunoshCommand('failing-task', {
        cwd: testDir,
        env: { NODE_ENV: 'test' }
      });
      
      // Task should complete but show failures in output
      expect(result.success).toBe(true); // Process succeeds in test mode
      expect(result.exitCode).toBe(0);   // Exit code 0 in test mode
      expect(result.stdout).toContain('Failed: 1'); // But reports failure (only subtask fails, parent returns TaskResult)
      
      // Check for failure indication (different formats in CI vs local)
      const hasExitCodeMessage = result.stdout.includes('exit code: 1') || result.stdout.includes('Exit code: 1');
      const hasCIErrorFormat = result.stdout.includes('❌ [exec]');
      expect(hasExitCodeMessage || hasCIErrorFormat).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('Parallel Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should execute parallel tasks with prefixes', async () => {
      const result = await runBunoshCommand('parallel-task', {
        cwd: testDir,
        timeout: 20000
      });
      
      expect(result.success).toBe(true);
      
      // Check for task outputs
      expect(result.stdout).toContain('Task 1 output');
      expect(result.stdout).toContain('Task 2 output');
      expect(result.stdout).toContain('Task 3 output');
      
      // Check for angle bracket prefixes (when tasks run in parallel)
      const hasParallelPrefixes = result.stdout.includes('❰1❱') || 
                                result.stdout.includes('❰2❱') || 
                                result.stdout.includes('❰3❱');
      expect(hasParallelPrefixes).toBe(true);
    });

    it('should execute composite task calling other tasks', async () => {
      const result = await runBunoshCommand('composite-task', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
      expect(result.stdout).toContain('Composite task completed');
      
      // Check that file was created by composite task
      const outputFile = path.join(testDir, 'composite-output.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });

  describe.skipIf(!isBunAvailable)('NPM Scripts Integration', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir, {
        'custom-script': 'echo "Custom npm script executed"',
        'bunosh-script': 'bunosh simple:exec' // This should be filtered out
      });
    });

    it('should list npm scripts in help output', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('npm:test');
      expect(result.stdout).toContain('npm:build');
      expect(result.stdout).toContain('npm:custom-script');
      
      // Should not contain bunosh scripts
      expect(result.stdout).not.toContain('npm:bunosh-script');
    });

    it('should execute npm script through bunosh', async () => {
      const result = await runBunoshCommand('npm:custom-script', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Custom npm script executed');
    });

    it('should execute standard npm test script', async () => {
      const result = await runBunoshCommand('npm:test', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('running test');
    });
  });

  describe.skipIf(!isBunAvailable)('Command Listing and Help', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should show bunosh and npm commands in separate sections', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      const lines = result.stdout.split('\n');
      
      // Find Commands section
      const commandsStartIndex = lines.findIndex(line => line.includes('Commands:'));
      const commandsEndIndex = lines.findIndex((line, idx) => 
        idx > commandsStartIndex && line.includes('NPM Scripts:')
      );
      
      // Find NPM Scripts section  
      const npmStartIndex = lines.findIndex(line => line.includes('NPM Scripts:'));
      const npmEndIndex = lines.findIndex((line, idx) => 
        idx > npmStartIndex && line.includes('Special Commands:')
      );
      
      expect(commandsStartIndex).toBeGreaterThan(-1);
      expect(npmStartIndex).toBeGreaterThan(-1);
      expect(commandsEndIndex).toBeGreaterThan(commandsStartIndex);
      expect(npmEndIndex).toBeGreaterThan(npmStartIndex);
      
      // Parse bunosh commands section
      const bunoshCommandSection = lines.slice(commandsStartIndex + 1, commandsEndIndex);
      const bunoshCommands = bunoshCommandSection
        .filter(line => line.trim() && !line.includes('Commands:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.includes('-') && !cmd.startsWith('npm:'));
      
      // Parse npm commands section
      const npmCommandSection = lines.slice(npmStartIndex + 1, npmEndIndex);
      const npmCommands = npmCommandSection
        .filter(line => line.trim() && !line.includes('NPM Scripts:'))
        .map(line => {
          const cleanedLine = line.trim().replace(/\x1B\[[0-9;]*m/g, '');
          return cleanedLine.split(/\s+/)[0];
        })
        .filter(cmd => cmd && cmd.startsWith('npm:'));
      
      // Verify bunosh commands are alphabetically ordered
      const sortedBunoshCommands = [...bunoshCommands].sort();
      expect(bunoshCommands).toEqual(sortedBunoshCommands);
      
      // Verify npm commands are alphabetically ordered
      const sortedNpmCommands = [...npmCommands].sort();
      expect(npmCommands).toEqual(sortedNpmCommands);
      
      // Should contain both bunosh and npm commands
      expect(bunoshCommands.some(cmd =>
        ['simple-exec', 'fetch-task', 'file-task', 'yell-task', 'composite-task', 'parallel-task', 'task-with-args', 'failing-task'].includes(cmd)
      )).toBe(true);
      
      expect(npmCommands.some(cmd => cmd.startsWith('npm:'))).toBe(true);
    });

    it('should show command descriptions and usage', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Simple exec command');
      expect(result.stdout).toContain('Fetch data from API');
      expect(result.stdout).toContain('Task with arguments and options');
    });
  });

  describe.skipIf(!isBunAvailable)('Error Handling', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should handle unknown command gracefully', async () => {
      const result = await runBunoshCommand('unknown:command', { cwd: testDir });

      // Unknown commands should show help and exit with error code
      expect(result.success).toBe(false);
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Unknown command unknown:command');
      expect(result.stdout).toContain('Usage: bunosh [-e <code>] <command> <args> [options]');
    });

    it('should handle missing Bunoshfile', async () => {
      // Remove Bunoshfile
      fs.unlinkSync(path.join(testDir, 'Bunoshfile.js'));
      
      const result = await runBunoshCommand('some:command', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
    });
  });

  describe.skipIf(!isBunAvailable)('Task Formatting and Output', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should show parent task description in child exec commands', async () => {
      const script = `
        await task('Fetch all users', async () => {
          await exec\`echo "Fetching data..."\`;
          return 'Users fetched';
        });
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('✔ exec Fetch all users > echo "Fetching data..."');
    });

    it('should show numbered prefixes for parallel tasks', async () => {
      const script = `
        await Promise.all([
          task('Task 1', () => exec\`echo "Output 1"\`),
          task('Task 2', () => exec\`echo "Output 2"\`),
          task('Task 3', () => exec\`echo "Output 3"\`)
        ]);
      `;

      const result = await runBunoshScript(script, {
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });

      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      // First task may not have prefix due to race condition, but subsequent tasks should
      expect(cleaned.stdout).toMatch(/▶ task ❰2❱ Task 2/);
      expect(cleaned.stdout).toMatch(/▶ task ❰3❱ Task 3/);
      // Should have at least 2 tasks with prefixes (indicating parallel execution)
      const prefixMatches = cleaned.stdout.match(/▶ task ❰\d+❱/g) || [];
      expect(prefixMatches.length).toBeGreaterThan(1);
    });

    it('should not show prefixes for single tasks', async () => {
      const script = `
        await task('Single task', () => exec\`echo "Single task output"\`);
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('▶ task');
      expect(cleaned.stdout).toContain('Single task');
      expect(cleaned.stdout).not.toMatch(/✔ task ❰\\d+❱ Single task/);
    });

    it('should handle task failures correctly', async () => {
      const script = `
        try {
          await task('Task that fails', async () => {
            await exec\`sh -c "exit 1"\`;
          });
        } catch (e) {
          // Task failure should be caught
        }
      `;
      
      const result = await runBunoshScript(script, { 
        cwd: testDir,
        env: { BUNOSH_FORMATTER: 'console' }
      });
      
      const cleaned = cleanTestOutput(result);
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('✗ exec Task that fails > sh -c "exit 1"');
      expect(cleaned.stdout).toContain('✔ task Task that fails');
    });
  });

  describe.skipIf(!isBunAvailable)('Namespace Support', () => {
    it('should load multiple Bunoshfiles with namespaces', async () => {
      // Create main Bunoshfile
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function build() {
  console.log('Building main project...');
}

export function test() {
  console.log('Running main tests...');
}
`);

      // Create namespaced Bunoshfiles
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function start() {
  console.log('Starting dev server...');
}

export function debug() {
  console.log('Debugging application...');
}
`);

      fs.writeFileSync(path.join(testDir, 'Bunoshfile.api.js'), `
export function deploy() {
  console.log('Deploying API...');
}

export function test() {
  console.log('Running API tests...');
}
`);

      const result = await runBunoshCommand('', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      // Should show all commands from all namespaces
      expect(cleaned.stdout).toContain('build');
      expect(cleaned.stdout).toContain('test');
      expect(cleaned.stdout).toContain('dev:start');
      expect(cleaned.stdout).toContain('dev:debug');
      expect(cleaned.stdout).toContain('api:deploy');
      expect(cleaned.stdout).toContain('api:test');
    });

    it('should execute namespaced tasks correctly', async () => {
      // Create test files
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function shared() {
  console.log('Main shared task');
}
`);

      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function shared() {
  console.log('Dev shared task');
}

export function devOnly() {
  console.log('Dev only task');
}
`);

      // Test main task (no namespace)
      const result1 = await runBunoshCommand('shared', { cwd: testDir });
      const cleaned1 = cleanTestOutput(result1);
      expect(cleaned1.success).toBe(true);
      expect(cleaned1.stdout).toContain('Main shared task');

      // Test namespaced task
      const result2 = await runBunoshCommand('dev:shared', { cwd: testDir });
      const cleaned2 = cleanTestOutput(result2);
      expect(cleaned2.success).toBe(true);
      expect(cleaned2.stdout).toContain('Dev shared task');

      // Test namespace-only task
      const result3 = await runBunoshCommand('dev:dev-only', { cwd: testDir });
      const cleaned3 = cleanTestOutput(result3);
      expect(cleaned3.success).toBe(true);
      expect(cleaned3.stdout).toContain('Dev only task');
    });

    it('should handle task arguments and options in namespaced tasks', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function greet(name = 'World', enthusiastic = false) {
  const message = enthusiastic 
    ? "Hello " + name + "! Welcome to the amazing dev environment!"
    : "Hello " + name;
  console.log(message);
}
`);

      // Test with default values
      const result1 = await runBunoshCommand('dev:greet', { cwd: testDir });
      const cleaned1 = cleanTestOutput(result1);
      expect(cleaned1.success).toBe(true);
      expect(cleaned1.stdout).toContain('Hello World');

      // Test with arguments
      const result2 = await runBunoshCommand('dev:greet Alice', { cwd: testDir });
      const cleaned2 = cleanTestOutput(result2);
      expect(cleaned2.success).toBe(true);
      expect(cleaned2.stdout).toContain('Hello Alice');

      // Test with boolean argument
      const result3 = await runBunoshCommand('dev:greet Alice true', { cwd: testDir });
      const cleaned3 = cleanTestOutput(result3);
      expect(cleaned3.success).toBe(true);
      expect(cleaned3.stdout).toContain('Hello Alice! Welcome to the amazing dev environment!');
    });

    it('should show help for namespaced tasks', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
/**
 * Starts the development server
 * @param {number} port - The port to run on
 * @param {boolean} https - Enable HTTPS
 */
export function start(port = 3000, https = false) {
  console.log("Starting server on port " + port + " with HTTPS: " + https);
}
`);

      // Check that namespaced task appears in general help
      const result = await runBunoshCommand('--help', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('dev:start');
      expect(cleaned.stdout).toContain('Starts the development server');
      expect(cleaned.stdout).toContain('bunosh dev:start [port=3000] [https=false]');
    });

    it('should handle non-existent namespaced tasks gracefully', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function existing() {
  console.log('This exists');
}
`);

      const result = await runBunoshCommand('dev:nonexistent', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(false);
      expect(cleaned.stderr).toContain('Unknown command');
    });

    it('should work with no namespace Bunoshfile only', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), `
export function mainTask() {
  console.log('Main task executed');
}
`);

      const result = await runBunoshCommand('main-task', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('Main task executed');
    });

    it('should work with namespaced Bunoshfiles only', async () => {
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.js'), '');
      fs.writeFileSync(path.join(testDir, 'Bunoshfile.dev.js'), `
export function devTask() {
  console.log('Dev task executed');
}
`);

      const result = await runBunoshCommand('dev:dev-task', { cwd: testDir });
      const cleaned = cleanTestOutput(result);
      
      expect(cleaned.success).toBe(true);
      expect(cleaned.stdout).toContain('Dev task executed');
    });
  });
});