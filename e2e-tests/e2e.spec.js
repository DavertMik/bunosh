import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { 
  createTempTestDir, 
  cleanupTempDir, 
  createTestPackageJson, 
  createTestBunoshfile 
} from './helpers/test-env.js';
import { 
  runBunoshCommand, 
  runSystemCommand, 
  checkBunoshAvailable 
} from './helpers/command-runner.js';

describe('Bunosh End-to-End Tests', () => {
  let testDir;
  let originalCwd;

  beforeEach(() => {
    originalCwd = process.cwd();
    testDir = createTempTestDir();
    process.chdir(testDir);
  });

  afterEach(() => {
    process.chdir(originalCwd);
    cleanupTempDir(testDir);
  });

  describe('Environment Setup', () => {
    it('should have bunosh binary available', async () => {
      const available = await checkBunoshAvailable();
      // If this fails, it might be due to runtime environment differences
      expect(available).toBe(true);
    }, 10000);

    it('should create isolated test directory', () => {
      expect(fs.existsSync(testDir)).toBe(true);
      expect(process.cwd()).toBe(testDir);
    });
  });

  describe('Bunosh Initialization', () => {
    it('should initialize Bunoshfile with bunosh init', async () => {
      const result = await runBunoshCommand('init', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      
      // Check that Bunoshfile.js was created
      const bunoshfilePath = path.join(testDir, 'Bunoshfile.js');
      expect(fs.existsSync(bunoshfilePath)).toBe(true);
      
      // Check Bunoshfile content
      const content = fs.readFileSync(bunoshfilePath, 'utf8');
      expect(content).toContain('export async function');
      expect(content).toContain('helloWorld');
    });

    it('should show error message without Bunoshfile', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      // Without a Bunoshfile, bunosh shows an error and exits with code 1
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
      expect(result.stdout).toContain('bunosh init');
    });
  });

  describe('Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should execute simple exec task', async () => {
      const result = await runBunoshCommand('simple:exec', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // The exec task may have different output format, just check it ran without error
      expect(result.exitCode).toBe(0);
    });

    it('should execute file task and create output file', async () => {
      const result = await runBunoshCommand('file:task custom-file.txt', { cwd: testDir });
      
      // File task should complete without errors
      expect(result.success).toBe(true);
      
      // Check that file was created
      const outputFile = path.join(testDir, 'custom-file.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
      
      const content = fs.readFileSync(outputFile, 'utf8');
      expect(content).toContain('Generated by Bunosh test task');
    });

    it('should execute yell task with ASCII art output', async () => {
      const result = await runBunoshCommand('yell:task TESTING', { cwd: testDir });
      
      expect(result.success).toBe(true);
      // ASCII art task should run successfully
      expect(result.exitCode).toBe(0);
    });

    it('should execute fetch task', async () => {
      const result = await runBunoshCommand('fetch:task', { 
        cwd: testDir,
        timeout: 20000 // Longer timeout for network request
      });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Fetched data:');
    });

    it('should handle task with arguments and options', async () => {
      const result = await runBunoshCommand('task:with-args World --greeting=Hi', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hi, World!');
    });

    it('should handle failing task properly', async () => {
      const result = await runBunoshCommand('failing:task', { cwd: testDir });
      
      // Task should complete but show failures in output
      expect(result.success).toBe(true); // Process succeeds in test mode
      expect(result.exitCode).toBe(0);   // Exit code 0 in test mode
      expect(result.stdout).toContain('Failed: 1'); // But reports failure
      
      // Check for failure indication (different formats in CI vs local)
      const hasExitCodeMessage = result.stdout.includes('exit code: 1') || result.stdout.includes('Exit code: 1');
      const hasCIErrorFormat = result.stdout.includes('❌ [exec]');
      expect(hasExitCodeMessage || hasCIErrorFormat).toBe(true);
    });
  });

  describe('Parallel Task Execution', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should execute parallel tasks with prefixes', async () => {
      const result = await runBunoshCommand('parallel:task', { 
        cwd: testDir,
        timeout: 20000
      });
      
      expect(result.success).toBe(true);
      
      // Check for task outputs
      expect(result.stdout).toContain('Task 1 output');
      expect(result.stdout).toContain('Task 2 output');
      expect(result.stdout).toContain('Task 3 output');
      
      // Check for angle bracket prefixes (when tasks run in parallel)
      const hasParallelPrefixes = result.stdout.includes('❰1❱') || 
                                result.stdout.includes('❰2❱') || 
                                result.stdout.includes('❰3❱');
      expect(hasParallelPrefixes).toBe(true);
    });

    it('should execute composite task calling other tasks', async () => {
      const result = await runBunoshCommand('composite:task', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Hello from exec');
      expect(result.stdout).toContain('Composite task completed');
      
      // Check that file was created by composite task
      const outputFile = path.join(testDir, 'composite-output.txt');
      expect(fs.existsSync(outputFile)).toBe(true);
    });
  });

  describe('NPM Scripts Integration', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir, {
        'custom-script': 'echo "Custom npm script executed"',
        'bunosh-script': 'bunosh simple:exec' // This should be filtered out
      });
    });

    it('should list npm scripts in help output', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('npm:test');
      expect(result.stdout).toContain('npm:build');
      expect(result.stdout).toContain('npm:custom-script');
      
      // Should not contain bunosh scripts
      expect(result.stdout).not.toContain('npm:bunosh-script');
    });

    it('should execute npm script through bunosh', async () => {
      const result = await runBunoshCommand('npm:custom-script', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Custom npm script executed');
    });

    it('should execute standard npm test script', async () => {
      const result = await runBunoshCommand('npm:test', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('running test');
    });
  });

  describe('Command Listing and Help', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
      createTestPackageJson(testDir);
    });

    it('should show mixed bunosh and npm commands in alphabetical order', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      
      const lines = result.stdout.split('\n');
      const commandSection = lines.slice(
        lines.findIndex(line => line.includes('Commands:')),
        lines.findIndex(line => line.includes('Special Commands:'))
      );
      
      const commands = commandSection
        .filter(line => line.trim() && !line.includes('Commands:'))
        .filter(line => !line.startsWith('    ')) // Filter out indented usage lines
        .map(line => line.trim().split(/\s+/)[0])
        .filter(cmd => cmd && cmd.length > 0 && !cmd.startsWith('Usage:'));
      
      // Verify alphabetical ordering
      const sortedCommands = [...commands].sort();
      expect(commands).toEqual(sortedCommands);
      
      // Should contain both bunosh and npm commands  
      expect(commands.some(cmd => cmd.startsWith('simple:'))).toBe(true);
      expect(commands.some(cmd => cmd.startsWith('npm:'))).toBe(true);
    });

    it('should show command descriptions and usage', async () => {
      const result = await runBunoshCommand('--help', { cwd: testDir });
      
      expect(result.success).toBe(true);
      expect(result.stdout).toContain('Simple exec command');
      expect(result.stdout).toContain('Fetch data from API');
      expect(result.stdout).toContain('Task with arguments and options');
    });
  });

  describe('Error Handling', () => {
    beforeEach(() => {
      createTestBunoshfile(testDir);
    });

    it('should handle unknown command gracefully', async () => {
      const result = await runBunoshCommand('unknown:command', { cwd: testDir });
      
      // Commander shows help and continues normally for unknown commands
      expect(result.success).toBe(true);
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('Unknown command unknown:command');
      expect(result.stdout).toContain('Usage: bunosh <command>');
    });

    it('should handle missing Bunoshfile', async () => {
      // Remove Bunoshfile
      fs.unlinkSync(path.join(testDir, 'Bunoshfile.js'));
      
      const result = await runBunoshCommand('some:command', { cwd: testDir });
      
      expect(result.success).toBe(false);
      expect(result.stderr).toContain('Bunoshfile not found');
    });
  });
});